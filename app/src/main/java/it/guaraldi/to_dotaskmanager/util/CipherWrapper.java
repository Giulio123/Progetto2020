package it.guaraldi.to_dotaskmanager.util;

import android.util.Base64;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.nio.charset.Charset;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;

public class CipherWrapper {
    private static final String TAG = "CipherWrapper";
    public static final String TRANSFORMATION_ASYMMETRIC = "RSA/ECB/PKCS1Padding";
    public static final String TRANSFORMATION_SYMMETRIC = "AES/CBC/PKCS7Padding";
    public static final String IV_SEPARATOR = "]";
    public static final String base64Regex = "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$";
    private String transformation;
    public Cipher cipher;

    public CipherWrapper (String transformation){
        this.transformation = transformation;
        try {
            cipher = Cipher.getInstance(transformation);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }


    /**
     * Encrypts data using the key.
     *
     * @param data the data to encrypt
     * @param key the key to encrypt data with
     * @param useInitializationVector encrypt data using initialization vector generated by system. Vector will be added
     * as a prefix to the result of encryption, separated with [IV_SEPARATOR]. Result example - "aaaaaa]bbbbbb", where `aaaaaa`
     * is an created Initialization Vector and `bbbbbb` the  encrypted to data. `false` by default.
     *
     */
    public String encrypt(String data, @Nullable Key key, boolean useInitializationVector){
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            String res = "";

            if(useInitializationVector){
                byte [] iv = cipher.getIV();
                String ivString = Base64.encodeToString(iv,Base64.DEFAULT);
                res = ivString + IV_SEPARATOR;
            }

            byte [] bytes = cipher.doFinal(data.getBytes());
            res += Base64.encodeToString(bytes,Base64.DEFAULT);
            return res;
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String encrypt(String data, @Nullable Key key){
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte [] bytes = cipher.doFinal(data.getBytes(Charset.defaultCharset()));
            return Base64.encodeToString(bytes,Base64.DEFAULT).replaceAll("[\\n]","");
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Decrypts data using the key.
     *
     * @param data the data to decrypt
     * @param key the key to decrypt data with
     * @param useInitializationVector decrypt data using initialization vector. Vector must be added
     * as a prefix to the encryption data, separated with [IV_SEPARATOR]. Data example - "aaaaaa]bbbbbb", where `aaaaaa`
     * is an Initialization Vector and `bbbbbb` the  data to decrypt. `false` by default.
     */
    public String decrypt(String data, @Nullable Key key, boolean useInitializationVector){
        try {
            String encodedString;
            if (useInitializationVector) {
                String[] split = data.split(IV_SEPARATOR);
                if (split.length != 2)
                    throw new IllegalArgumentException("Passed data is incorrect. There was no IV specified with it.");
                String ivString = split[0];
                encodedString = split[1];
                IvParameterSpec ivSpec = new IvParameterSpec(Base64.decode(ivString, Base64.DEFAULT));
                cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);
            } else {
                encodedString = data;
                cipher.init(Cipher.DECRYPT_MODE, key);
            }
            byte[] encryptedData = Base64.decode(encodedString, Base64.DEFAULT);
            byte[] decodedData = cipher.doFinal(encryptedData);
            return new String(decodedData);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String decrypt(String data, @Nullable Key key){
        try {
            cipher.init(Cipher.DECRYPT_MODE,key);
            byte[] encryptedData = Base64.decode(data.getBytes(Charset.defaultCharset()), Base64.DEFAULT);
            byte[] decodedData = cipher.doFinal(encryptedData);
            return new String(decodedData);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Wraps(encrypts) a key with another key.
     */
    public String wrapKey( Key keyToBeWrapped, @Nullable Key keyToWrapWith){
        try {
            cipher.init(Cipher.WRAP_MODE,keyToWrapWith);
            byte [] decodedData = cipher.wrap(keyToBeWrapped);
            return Base64.encodeToString(decodedData, Base64.DEFAULT);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * Unwraps(decrypts) a key with another key. Requires wrapped key algorithm and type.
     */
    public Key unWrapKey(String wrappedKeyData, String algorithm, int wrappedKeyType, @Nullable Key keyToUnWrapWith){
        try {
            byte [] encryptedKeyData = Base64.decode(wrappedKeyData, Base64.DEFAULT);
            cipher.init(Cipher.UNWRAP_MODE, keyToUnWrapWith);
            return cipher.unwrap(encryptedKeyData,algorithm,wrappedKeyType);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
}
